<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Vert.x 4 Future | blog.rasvi.io</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Vert.x 4 Future" />
<meta name="author" content="Mohamed Rasvi" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Vert.x is a highly performant asynchronous library. It is a great fit for IO heavy applications. Good thing about vert.x is, it is just a library that you can create the objects anywhere and use it out of the box. You can easily embed this to your application. Vert.x 4 has added Future support. This Future io.vertx.core.Future is not same as java.util.concurrent.Future You can refer the javadoc here. You need to include the maven dependency. Or you can clone this repository &amp;#x3C;dependency&amp;#x3E; &amp;#x3C;groupId&amp;#x3E;io.vertx&amp;#x3C;/groupId&amp;#x3E; &amp;#x3C;artifactId&amp;#x3E;vertx-web-client&amp;#x3C;/artifactId&amp;#x3E; &amp;#x3C;version&amp;#x3E;4.4.2&amp;#x3C;/version&amp;#x3E; &amp;#x3C;/dependency&amp;#x3E; Every asynchronous operation method from Vert.x has an alternate version of it to return a Future. Prior to Vert.x 4 every asynchronous operation needs to be passed a callback which leads to callback hell. Lets look at a http client usage. Vert.x 3 callback client.getAbs(url).send(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22;+ response); }); Vert.x 4 Future Future&amp;#x3C;HttpResponse&amp;#x3C;Buffer&amp;#x3E;&amp;#x3E; future = client.getAbs(url).send(); future.onComplete(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22; + response); });" />
<meta property="og:description" content="Vert.x is a highly performant asynchronous library. It is a great fit for IO heavy applications. Good thing about vert.x is, it is just a library that you can create the objects anywhere and use it out of the box. You can easily embed this to your application. Vert.x 4 has added Future support. This Future io.vertx.core.Future is not same as java.util.concurrent.Future You can refer the javadoc here. You need to include the maven dependency. Or you can clone this repository &amp;#x3C;dependency&amp;#x3E; &amp;#x3C;groupId&amp;#x3E;io.vertx&amp;#x3C;/groupId&amp;#x3E; &amp;#x3C;artifactId&amp;#x3E;vertx-web-client&amp;#x3C;/artifactId&amp;#x3E; &amp;#x3C;version&amp;#x3E;4.4.2&amp;#x3C;/version&amp;#x3E; &amp;#x3C;/dependency&amp;#x3E; Every asynchronous operation method from Vert.x has an alternate version of it to return a Future. Prior to Vert.x 4 every asynchronous operation needs to be passed a callback which leads to callback hell. Lets look at a http client usage. Vert.x 3 callback client.getAbs(url).send(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22;+ response); }); Vert.x 4 Future Future&amp;#x3C;HttpResponse&amp;#x3C;Buffer&amp;#x3E;&amp;#x3E; future = client.getAbs(url).send(); future.onComplete(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22; + response); });" />
<link rel="canonical" href="https://blog.rasvi.io/2023-05-20-vertx4-future" />
<meta property="og:url" content="https://blog.rasvi.io/2023-05-20-vertx4-future" />
<meta property="og:site_name" content="blog.rasvi.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-20T11:07:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Vert.x 4 Future" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mohamed Rasvi"},"dateModified":"2023-05-20T11:07:00+05:30","datePublished":"2023-05-20T11:07:00+05:30","description":"Vert.x is a highly performant asynchronous library. It is a great fit for IO heavy applications. Good thing about vert.x is, it is just a library that you can create the objects anywhere and use it out of the box. You can easily embed this to your application. Vert.x 4 has added Future support. This Future io.vertx.core.Future is not same as java.util.concurrent.Future You can refer the javadoc here. You need to include the maven dependency. Or you can clone this repository &amp;#x3C;dependency&amp;#x3E; &amp;#x3C;groupId&amp;#x3E;io.vertx&amp;#x3C;/groupId&amp;#x3E; &amp;#x3C;artifactId&amp;#x3E;vertx-web-client&amp;#x3C;/artifactId&amp;#x3E; &amp;#x3C;version&amp;#x3E;4.4.2&amp;#x3C;/version&amp;#x3E; &amp;#x3C;/dependency&amp;#x3E; Every asynchronous operation method from Vert.x has an alternate version of it to return a Future. Prior to Vert.x 4 every asynchronous operation needs to be passed a callback which leads to callback hell. Lets look at a http client usage. Vert.x 3 callback client.getAbs(url).send(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22;+ response); }); Vert.x 4 Future Future&amp;#x3C;HttpResponse&amp;#x3C;Buffer&amp;#x3E;&amp;#x3E; future = client.getAbs(url).send(); future.onComplete(response -&amp;#x3E; { System.out.println(&amp;#x22;Response: &amp;#x22; + response); });","headline":"Vert.x 4 Future","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.rasvi.io/2023-05-20-vertx4-future"},"url":"https://blog.rasvi.io/2023-05-20-vertx4-future"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.rasvi.io/feed.xml" title="blog.rasvi.io" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-76YBPTXB5Y', 'auto');
  ga('send', 'pageview');
}
</script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">blog.rasvi.io</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About (Mohamed Rasvi)</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Vert.x 4 Future</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-05-20T11:07:00+05:30" itemprop="datePublished">May 20, 2023
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Mohamed Rasvi</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Vert.x is a highly performant asynchronous library. It is a great fit for IO heavy applications. Good thing about vert.x is, it is just a library that you can create the objects anywhere and use it out of the box. You can easily embed this to your application. Vert.x 4 has added Future support. This Future <span><code>io.vertx.core.Future</code></span> is not same as <span><code>java.util.concurrent.Future</code></span> You can refer the javadoc <a target="_blank" href="https://vertx.io/docs/apidocs/io/vertx/core/Future.html">here</a>.</p>
<p>You need to include the maven dependency. Or you can clone this <a href="https://github.com/rasvi24/vertx-web-future">repository</a></p>
<pre>
&#x3C;dependency&#x3E;
  &#x3C;groupId&#x3E;io.vertx&#x3C;/groupId&#x3E;
  &#x3C;artifactId&#x3E;vertx-web-client&#x3C;/artifactId&#x3E;
  &#x3C;version&#x3E;4.4.2&#x3C;/version&#x3E;
&#x3C;/dependency&#x3E;
</pre>
<p>Every asynchronous operation method from Vert.x has an alternate version of it to return a Future. Prior to Vert.x 4 every asynchronous operation needs to be passed a callback which leads to callback hell. Lets look at a http client usage.</p>
<h4>Vert.x 3 callback</h4>
<pre>
client.getAbs(url).send(response -&#x3E; {
  System.out.println(&#x22;Response: &#x22;+ response);
});
</pre>
<h4>Vert.x 4 Future</h4>
<pre>
Future&#x3C;HttpResponse&#x3C;Buffer&#x3E;&#x3E; future = client.getAbs(url).send();
future.onComplete(response -&#x3E; {
  System.out.println(&#x22;Response: &#x22; + response);
});
</pre>

<p>They both seem to be similar at first. The Future version still has callback for onComplete. This is very useful when we pass around the future to different part of the code and continue the completion there. This usage avoids callback hell or nesting callbacks on multiple levels.</p>
<h4>compose</h4>
<p>Let's take an example with a shortened link. On hitting the shortened link gives the original link. This means we need to perform two asynchronous operations and the second operation is dependant on the first operation. This can be written in Vert.x 4 without nesting callbacks.</p>
<pre>
Future&#x3C;HttpResponse&#x3C;Buffer&#x3E;&#x3E; future = client.getAbs(shortLink).send();
future.compose(resp -&#x3E; {
    String originalLink = resp.bodyAsString();
    return client.getAbs(originalLink).send();
});</pre>
<p>The compose method from Future returns another Future. it is useful to chain multiple dependant operations as if they were written line by line in a blocking java code. This Future object now can be returned to anywhere in the code to execute different operation with the result of it.</p>

<h4>map</h4>
<p>You can use map method to transform the result of the future. The mapping operation is done asynchronously when the result is available.</p>
<pre>
public Future&#x3C;JsonObject&#x3E; fetchJsonData(WebClient client, String url) {
  Future&#x3C;HttpResponse&#x3C;Buffer&#x3E;&#x3E; future = client.getAbs(url).send();
  return future.map(res -&#x3E; res.bodyAsJsonObject());
}
</pre>
  </div><a class="u-url" href="/2023-05-20-vertx4-future" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">blog.rasvi.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">blog.rasvi.io</li><li><a class="u-email" href="mailto:rasvimohamed7@gmail.com">rasvimohamed7@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/rasvi24"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">rasvi24</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I experiment any technologies that interests me. Some of the technologies I work with are AWS, Kubernetes, Java EE, Spring Boot, Python and Javascript. I make myself to write them here.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
